#pragma once

#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/foreach.hpp>
#include <boost/optional.hpp>
#include <Windows.h>
#include <iostream>
#include <string>
#include <vector> 
#include "CONSTANTSTRING.h"

namespace process {
	using namespace std;
	using namespace System;
	using namespace constantstring;
	using namespace boost::property_tree;

	//作成日：2017.9.2
	//作成者：K.Asada
	//文字列を処理する関数群クラス。
	ref class StringProcess {
	public:
		//定数クラスをインスタンス化
		CONSTANTSTRING^ MyConst = gcnew CONSTANTSTRING();
		Int32^ column = *MyConst->ZERO;		//表の列数
		Int32^ row = *MyConst->ZERO;		//表の行数
		Int32^ tmp = *MyConst->ZERO;
		vector<pair<string, string>>* table = new vector<pair<string, string>>();
		//デフォルトコンストラクタ
		StringProcess() {
		};

		//ファイルパスより文字列を取得してその文字列から行数、列数、文字列を抜き出す。
		vector<pair<string, string>>* ReadyString(String^ JSONPath) {
			ptree pt;		//ファイルより取得したJSONを格納するツリー
		//	String^ SJSON = "";
			string JSON = "";
			string path = "";
			MarshalString(JSONPath, path);
			//受け取ったファイルパスより文字列を呼び出す。
			stringstream ss;
			std::ifstream ifs(path, ios_base::binary);
			ss << ifs.rdbuf();

			//取得した文字列よりJSONを取得する。
			read_json(ss, pt);

			//JSONから表の出力に必要な文字列を呼び出す。
			TableString(pt, "");
			//JSONから表の行数を割り出す関数を呼び出す。
			CountRows();
			this->tmp = *this->row;
			//JSONから表の列数を割り出す関数を呼び出す。
			CountColumn();

			this->row = *this->row - *this->column;
			//タイトルの行数を考慮して列数を補正する。
			this->column = *this->tmp / *this->row;

			return this->table;
		}

		/*出力する表の列数を割り出す関数
		作成日：2017.9.5
		作成者：K.Asada
		*/
		Void CountColumn() {
			//イテレーターにより走査する。
			for (auto itr = this->table->begin(); itr != this->table->end(); ++itr) {
				Int32 tmp = 0;
				//表の要素を見つけたら列数をカウント
				if (itr->first == "text" || itr->first == "array" || itr->first == "html") {
					*this->column += 1;
				}
				//結合を示すキー名があれば
				else if (itr->first == "colspan") {
					//結合の行数をプラスする
					*this->column += stoi(itr->second) - 1;
				}
			}
		}

		/*出力する表の行数を割り出すための関数
		作成日：2017.9.4
		作成者：K.Asada*/
		Void CountRows() {
			//イテレーターにより走査する。
			for (auto itr = this->table->begin(); itr != this->table->end(); ++itr) {
				//親のノードまたは子が配列の時に列数をカウント
				if ((itr->second == "" && (itr + 1)->first != "array") || itr->first == "array" || itr->first == "html") {
					//列数をインクリメント
					*this->row += 1;
				}
				else if (itr->first == "colspan") {
					//結合の行数をプラスする
					*this->row += stoi(itr->second) - 1;
				}
			}
		}

		/*出力する表に必要な文字列および列数を割り出すための関数
		作成日：2017.9.4
		作成者：K.Asada
		*/
		Void TableString(ptree pt, string key) {
			string childkey = "";		//再帰処理の時に必要な子のキー名を格納する文字列。
			//キー名が空の時（初回ループ時）
			if (key == "") {
				//キー名を取得するためのイテレーターを宣言。
				auto itr = pt.begin();
				//キー名をイテレーターより取得。
				key = itr->first;
			}
			//子に文字列があった場合
			if (boost::optional<std::string> str = pt.get_optional<std::string>(key)) {
				//文字列をキー名をペアにしてマップに格納する。
				this->table->push_back(pair<string, string>(UTF8toSjis(key), UTF8toSjis(str.get())));
			}
			//子に整数があった場合
			else if (boost::optional<int> value = pt.get_optional<int>(key)) {
				//キー名をペアにしてマップに格納する
				this->table->push_back(pair<string, string>(UTF8toSjis(key), UTF8toSjis(to_string(value.get()))));
			}
			//子がまだいる場合
			if (pt.get_child_optional(key)) {
				//子の兄弟を走査する
				BOOST_FOREACH(const ptree::value_type& child, pt.get_child(key)) {
					//判定を行うためにsecondを取得
					const ptree& info = child.second;
					//子のキー名を取得する
					childkey = child.first;
					//子要素が配列かつ整数であれば
					if (boost::optional<int> value = info.get_optional<int>(childkey)) {
						//キー名をペアにしてマップに格納する
						this->table->push_back(pair<string, string>(UTF8toSjis(childkey), UTF8toSjis(to_string(value.get()))));
					//子要素が配列かつ文字列であれば
					}
					else if (boost::optional<std::string> str = info.get_optional<std::string>(childkey)) {
						this->table->push_back(pair<string, string>(UTF8toSjis("array"), UTF8toSjis(str.get())));
						//文字列をキー名をペアにしてマップに格納する。					
					}
					else {
						//再帰処理を行う
						TableString(pt.get_child(key), childkey);
					}
				}
			}
		}

		//ファイルより文字列を取得する関数
		//作成日：2017.9．2
		//作成者：K.Asada
		String^ LoadJSON(String^ Path) {
			String^ retString = "";			//返却用文字列。
			//ファイルを開くためのクラスをインスタンス化
			System::IO::StreamReader^ reader = gcnew System::IO::StreamReader(Path);
			//ファイルに中身が存在するかを確認する。
			if (!reader->EndOfStream) {
				//返却用文字列にファイルから取得した文字列を格納。。
				retString = reader->ReadToEnd();
			}
			//読み取れなければエラーを返す。
			else {
				//ファイルの中身が存在していないエラーを表示する。
			}
			return retString;
		}

		/*String^型をstring型へ変換する関数
		作成日：2017.9.5
		作成者：K.Asada
		*/
		void MarshalString(String^ sys_string, string& std_string) {
			using namespace Runtime::InteropServices;
			const char* chars =
				(const char*)(Marshal::StringToHGlobalAnsi(sys_string)).ToPointer();
			std_string = chars;
			Marshal::FreeHGlobal(IntPtr((void*)chars));
		}

		/*文字コードの変換を行う関数
		作成日：2017.9.5
		作成者：K.Asada
		*/
		std::string UTF8toSjis(std::string srcUTF8) {
			//Unicodeへ変換後の文字列長を得る
			int lenghtUnicode = MultiByteToWideChar(CP_UTF8, 0, srcUTF8.c_str(), srcUTF8.size() + 1, NULL, 0);

			//必要な分だけUnicode文字列のバッファを確保
			wchar_t* bufUnicode = new wchar_t[lenghtUnicode];

			//UTF8からUnicodeへ変換
			MultiByteToWideChar(CP_UTF8, 0, srcUTF8.c_str(), srcUTF8.size() + 1, bufUnicode, lenghtUnicode);

			//ShiftJISへ変換後の文字列長を得る
			int lengthSJis = WideCharToMultiByte(CP_THREAD_ACP, 0, bufUnicode, -1, NULL, 0, NULL, NULL);

			//必要な分だけShiftJIS文字列のバッファを確保
			char* bufShiftJis = new char[lengthSJis];

			//UnicodeからShiftJISへ変換
			WideCharToMultiByte(CP_THREAD_ACP, 0, bufUnicode, lenghtUnicode + 1, bufShiftJis, lengthSJis, NULL, NULL);

			std::string strSJis(bufShiftJis);

			delete bufUnicode;
			delete bufShiftJis;

			return strSJis;
		}

		/*文字コードの変換を行う関数
		作成日：2017.9.5
		作成者：K.Asada*/
		std::string SjistoUTF8(std::string srcSjis) {
			//Unicodeへ変換後の文字列長を得る
			int lenghtUnicode = MultiByteToWideChar(CP_THREAD_ACP, 0, srcSjis.c_str(), srcSjis.size() + 1, NULL, 0);

			//必要な分だけUnicode文字列のバッファを確保
			wchar_t* bufUnicode = new wchar_t[lenghtUnicode];

			//ShiftJISからUnicodeへ変換
			MultiByteToWideChar(CP_THREAD_ACP, 0, srcSjis.c_str(), srcSjis.size() + 1, bufUnicode, lenghtUnicode);


			//UTF8へ変換後の文字列長を得る
			int lengthUTF8 = WideCharToMultiByte(CP_UTF8, 0, bufUnicode, -1, NULL, 0, NULL, NULL);

			//必要な分だけUTF8文字列のバッファを確保
			char* bufUTF8 = new char[lengthUTF8];

			//UnicodeからUTF8へ変換
			WideCharToMultiByte(CP_UTF8, 0, bufUnicode, lenghtUnicode + 1, bufUTF8, lengthUTF8, NULL, NULL);

			std::string strUTF8(bufUTF8);

			delete bufUnicode;
			delete bufUTF8;

			return strUTF8;
		}
	};
}